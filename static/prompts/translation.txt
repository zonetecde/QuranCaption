**Task**:  
Map **Arabic segments** from Quranic verses to their corresponding **word indices** in pre-existing indexed translations. For each verse, identify which words in the translation correspond to each Arabic segment and return **only JSON**.

---

**Inputs**:  
An array of objects, where each object contains:  
1. `index` (number): **Timeline position** of the first subtitle segment for that verse in the project (not necessarily sequential).
2. `verseKey` (string): The surah and verse number in the format "s:v" (e.g., "1:5").  
3. `segments` (array of strings): Arabic phrases to map from the verse.  
4. `translation` (string): Compact indexed translation format "index:word index:word..."

**Input Structure**:  
```json
[
  {
    "index": 0,
    "verseKey": "1:5",
    "segments": ["إِيَّاكَ نَعْبُدُ", "وَإِيَّاكَ نَسْتَعِينُ"],
    "translation": "0:You 1:˹alone˺ 2:we 3:worship 4:and 5:You 6:˹alone˺ 7:we 8:ask 9:for 10:help."
  }
]
```

**IMPORTANT PARSING NOTE**:  
- **Punctuation as separate words**: punctuation can be its own indexed word.
- **Example**: `"1:: 2:\"Il"` means index 1 is ":" and index 2 is "Il".
- **Do NOT ignore punctuation indices** - they must be included in ranges for complete coverage.
- **Format parsing**: split by spaces first, then by the **first colon** to separate index from word.

---

**Output Requirements**:  
- Return a **JSON object** with string keys corresponding to the `index` of each input verse.
- Each key maps to an array of index ranges `[start, end]` for each segment in the same order as provided.
- Each range `[start, end]` represents the **inclusive** indices of words in the translation.
- If a segment cannot be mapped, return `null` for that segment.
- **Output array length must equal `segments.length`** for that verse.
- **Do not renumber indexes** — use the exact `index` values provided in the input.
- All ranges must be within the translation index bounds `[0, maxIndex]`.
- **Output Format**: Pure JSON only, no additional text or explanation.

**Output Structure**:  
```json
{
  "0": [[start1, end1], [start2, end2], ...],
  "1": [[start1, end1], [start2, end2], ...],
  ...
}
```

---

**Core Rules (MUST FOLLOW)**:

1. **COMPLETE COVERAGE REQUIREMENT** (CRITICAL):
   - Every word index in the translation **must** appear in at least one segment range.
   - If translation has words 0-13, output must cover **all indices 0-13**.
   - Coverage must be achieved **without violating boundaries**; use the attachment rules below for filler/neutral tokens.

2. **EXACT SEGMENT BOUNDARIES** (CRITICAL):
   - Map only the words that correspond to the Arabic segment.
   - **Never extend** a segment into words that belong to the next segment.
   - If Arabic ends with "إِلَّا" (except), stop exactly at "except" — do **not** include what follows.

3. **CONTIGUOUS RANGES ONLY**:
   - Each segment must map to a **continuous** index range.
   - Valid: `[4, 7]` → indices 4,5,6,7.
   - Invalid: `[4, 7]` if index 5-6 do not belong to that segment.

4. **OVERLAP POLICY (MINIMIZE)**:
   - Arabic segments can overlap; translation ranges can overlap too.
   - **Minimize overlap**; use it only when required for shared boundary tokens, repeated clauses, or to keep coordination tokens.
   - Prefer overlap of **boundary tokens only** (1–2 tokens) unless a longer shared phrase is clearly repeated.

5. **COORDINATION & FUNCTION WORDS (CRITICAL)**:
   - If a segment **starts** with coordination particles (وَ, فَ, ثُمَّ, أَوْ, بَلْ, لَٰكِنْ, أَمْ),
     the mapped range **must include** their translation tokens (e.g., "and", "so", "then", "or", "rather", "but").
   - When clauses **repeat across segments**, keep the **conjunctions/prepositions** attached to the repeated clause.
   - **Do not drop "and/then/so"** just because the clause also appears in another segment.

6. **ACCURATE CORRESPONDENCE**:
   - Include all words needed to capture the full meaning of the segment.
   - Do not truncate essential words or include words from a different segment.

7. **UNALIGNED FILLER WORDS** (e.g., "indeed", "surely", "O"):
   - Attach filler words to the **nearest segment on the right**.
   - If there is no segment on the right, attach to the last segment on the left.
   - If multiple filler tokens are contiguous, attach them as a block to the chosen segment.

8. **PUNCTUATION ATTACHMENT**:
   - Punctuation belongs to the segment whose range contains the **nearest content word to the left**.
   - If punctuation appears at the very start (no left content word), attach it to the first segment.

9. **PRIORITY ORDER (TIE-BREAKERS)**:
   - **Boundaries + coordination tokens** > **contiguity** > **overlap policy** > **coverage**.
   - If coverage conflicts with boundaries, keep boundaries and assign leftover tokens using the attachment rules.

10. **NON-MAPPABLE SEGMENTS**:
   - If a segment truly cannot be mapped to any contiguous range, return `null`.
   - Still ensure coverage using attachment rules; **do not** violate boundaries.

---

**Examples**:

#### **Example 1: Basic Sequential Mapping**
- **Input**:  
  ```json
  [
    {
      "index": 0,
      "verseKey": "1:5",
      "segments": ["إِيَّاكَ نَعْبُدُ", "وَإِيَّاكَ نَسْتَعِينُ"],
      "translation": "0:You 1:˹alone˺ 2:we 3:worship 4:and 5:You 6:˹alone˺ 7:we 8:ask 9:for 10:help."
    }
  ]
  ```  
- **Output**:  
  ```json
  {
    "0": [[0, 3], [4, 10]]
  }
  ```  
- **Coverage Check**: 0-10 covered ✓

#### **Example 2: Overlapping Segments**
- **Input**:  
  ```json
  [
    {
      "index": 0,
      "verseKey": "1:6",
      "segments": ["اهْدِنَا الصِّرَاطَ", "الصِّرَاطَ الْمُسْتَقِيمَ"],
      "translation": "0:Guide 1:us 2:along 3:the 4:Straight 5:Path,"
    }
  ]
  ```  
- **Output**:  
  ```json
  {
    "0": [[0, 3], [3, 5]]
  }
  ```  
- **Coverage Check**: 0-5 covered ✓

#### **Example 3: Precise Boundaries with "except"**
- **Input**:  
  ```json
  [
    {
      "index": 0,
      "verseKey": "38:24",
      "segments": ["وَإِنَّ كَثِيرًا مِّنَ ٱلْخُلَطَآءِ لَيَبْغِى بَعْضُهُمْ عَلَىٰ بَعْضٍ إِلَّا", "إِلَّا ٱلَّذِينَ ءَامَنُوا۟ وَعَمِلُوا۟ ٱلصَّٰلِحَٰتِ"],
      "translation": "0:And 1:indeed, 2:many 3:associates 4:oppress 5:one 6:another, 7:except 8:for 9:those 10:who 11:believe 12:and 13:do 14:righteous 15:deeds."
    }
  ]
  ```  
- **Output**:  
  ```json
  {
    "0": [[0, 7], [7, 15]]
  }
  ```  
- **Boundary Check**: first segment ends at "except" (index 7).

#### **Example 4: Coordination Must Be Preserved**
- **Input**:  
  ```json
  [
    {
      "index": 0,
      "verseKey": "33:9",
      "segments": ["إِذْ جَاءَتْكُمْ جُنُودٌ", "وَأَرْسَلْنَا عَلَيْهِمْ رِيحًا"],
      "translation": "0:When 1:armies 2:came 3:to 4:you 5:and 6:We 7:sent 8:against 9:them 10:a 11:wind."
    }
  ]
  ```  
- **Output**:  
  ```json
  {
    "0": [[0, 4], [5, 11]]
  }
  ```  
- **Coordination Check**: second segment starts with "وَ" → must include "and" (index 5).

#### **Example 5: Overlap With Repeated Clause + Conjunction**
- **Input**:  
  ```json
  [
    {
      "index": 0,
      "verseKey": "x:y",
      "segments": ["إِذْ جَاءَتْكُمْ جُنُودٌ", "وَإِذْ جَاءَتْكُمْ جُنُودٌ"],
      "translation": "0:When 1:armies 2:came 3:to 4:you 5:and 6:when 7:armies 8:came 9:to 10:you"
    }
  ]
  ```  
- **Output**:  
  ```json
  {
    "0": [[0, 4], [5, 10]]
  }
  ```  
- **Repetition Rule**: second segment must include "and" (index 5) because it starts with "وَ".

#### **Example 6: Punctuation as Separate Words**
- **Input**:  
  ```json
  [
    {
      "index": 0,
      "verseKey": "112:1",
      "segments": ["قُلۡ", "هُوَ", "ٱللَّهُ", "أَحَدٌ"],
      "translation": "0:Dis 1:: 2:\"Il 3:est 4:Allah, 5:Unique."
    }
  ]
  ```  
- **Output**:  
  ```json
  {
    "0": [[0, 1], [2, 2], [3, 4], [5, 5]]
  }
  ```  
- **Punctuation Check**: index 1 ":" must be included.

---

**Edge Cases**:  
- **Empty Translation Array**: If `translation` is empty, return an array of `null` with length `segments.length`.  
- **No Mappable Segments**: If no segments can be mapped, return an array of `null` with length `segments.length`.  
- **Empty Input Array**: Return `{}`.  
- **Single Word Segments**: Map to `[n, n]`.

---

**Final Notes**:  
- **Return ONLY valid JSON** - no explanations or extra text.  
- Index ranges are **inclusive**.  
- Prioritize **accuracy** and **boundaries**, but still ensure **complete coverage**.

# The input :
